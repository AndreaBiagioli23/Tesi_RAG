<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>RAG Assistant</title>
  <style>
    body {
  font-family: Arial, sans-serif;
  background-color: #e0e7ff;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#rag-title {
  font-family: 'Merriweather', serif;
  font-size: 2em;
  font-weight: 400;
  color: #2c3e50;
  text-align: center;
  margin: 25px 0;
  font-style: italic;
  letter-spacing: 0.7px;
}

#chat-container {
  width: 90%;
  max-width: 700px;
  margin: 40px auto 120px auto;
  display: flex;
  flex-direction: column;
  background-color: #fff;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}

#response {
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 10px;
  border-radius: 8px;
  background-color: #f9f9f9;
}

.message {
  max-width: 80%;
  padding: 10px 15px;
  border-radius: 20px;
  word-wrap: break-word;
}

.user {
  align-self: flex-end;
  background-color: #d0f0fd;
  font-weight: bold;
}

.assistant {
  align-self: flex-start;
  background-color: #f1f1f1;
}

.assistant h1, .assistant h2, .assistant h3 {
  margin: 5px 0;
  font-weight: bold;
}

.assistant h2 {
  font-size: 1.2em;
  color: #333;
}

.assistant p {
  margin: 5px 0 10px 0;
  line-height: 1.4;
  color: #555;
}

.assistant ul {
  padding-left: 20px;
}

.assistant strong {
  font-weight: bold;
}

.ai-icon {
  display: inline-block;
  margin-right: 8px;
  animation: pulse 1s infinite;
  transform-origin: center;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}

#placeholder {
  text-align: center;
  color: #888;
  margin-top: 40px;
}

#input-container {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

input {
  flex: 1;
  padding: 10px;
  font-size: 1em;
  border-radius: 8px;
  border: 1px solid #ccc;
}

button {
  padding: 10px 20px;
  font-size: 1em;
  border-radius: 8px;
  border: none;
  background-color: #4CAF50;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s;
}

button:hover {
  background-color: #45a049;
}

/* Sidebar storico */
#toggleSidebar {
  position: fixed;
  top: 12px;
  left: 12px;
  z-index: 1100;
}

#sidebar {
  position: fixed;
  top: 0;
  left: -280px;
  width: 280px;
  height: 100vh;
  background: #ffffff;
  border-right: 1px solid #ddd;
  box-shadow: 2px 0 8px rgba(0,0,0,0.08);
  padding: 16px;
  box-sizing: border-box;
  overflow-y: auto;
  transition: left 0.25s ease;
  z-index: 1050;
}

#sidebar.open { left: 0; }

#sidebar h3 { margin: 0 0 8px 0; font-size: 18px; }

.chat-entry {
  padding: 8px;
  margin-bottom: 8px;
  border-radius: 8px;
  background: #f4f4f4;
  cursor: pointer;
  font-size: 14px;
  color: #333;
}

.chat-entry:hover { background: #e8e8e8; }

.hint { font-size: 12px; color: #666; margin-bottom: 10px; }

#closeSidebar, #newChatBtn {
  display: block;
  margin-bottom: 10px;
  padding: 6px 12px;
  border-radius: 6px;
  color: white;
  cursor: pointer;
  border: none;
}

#closeSidebar { background-color: #f44336; }
#newChatBtn { background-color: #2196F3; }

/* Logo RAG */
#rag-logo {
  width: 200px;
  margin: 10px 0 20px 0;
  animation: colorShift 6s infinite linear, pulse 2.5s infinite ease-in-out;
  filter: hue-rotate(0deg);
}

@keyframes colorShift {
  0%   { filter: hue-rotate(0deg); }
  50%  { filter: hue-rotate(120deg); }
  100% { filter: hue-rotate(240deg); }
}

#rag-badge {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #4f46e5;
  color: white;
  font-size: 12px;
  font-weight: bold;
  padding: 6px 10px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  animation: glow 2s infinite alternate;
  z-index: 1200;
}

@keyframes glow {
  from { box-shadow: 0 0 6px rgba(79,70,229,0.6); }
  to { box-shadow: 0 0 16px rgba(79,70,229,1); }
}

/* RAG Panel */
#rag-panel {
  position: fixed;
  top: 60px;
  left: 12px;
  width: 260px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  max-height: calc(100vh - 80px);
  overflow-y: auto;
  z-index: 1000;
}

#rag-info {
  width: 220px;
  background: white;
  padding: 12px;
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

#rag-info h4 {
  margin: 0 0 6px 0;
  font-size: 14px;
  font-weight: bold;
  color: #1e3a8a;
}

#rag-info p { margin: 4px 0; }
#rag-info .rag-expand { margin-left: 8px; }
#rag-info ul { margin: 4px 0; padding-left: 14px; }
#rag-info li { margin-bottom: 2px; }

.rag-clickable {
  cursor: pointer;
  user-select: none;
}
.rag-clickable:hover { text-decoration: underline; }

.rag-expand {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  opacity: 0;
  margin-left: 12px;
}
.rag-expand.open { max-height: 480px; opacity: 1; }

/* Docs, model, embed panels */
#docs-list ul, #docs-list li, #model-info p, #embed-info p {
  margin: 6px 0;
  padding-left: 16px;
  font-size: 12px;
  color: #374151;
  line-height: 1.4;
}

/* Help & Capabilities */
#rag-help, #rag-capabilities {
  width: 200px;
  background: #fff;
  padding: 12px;
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}
#rag-help { background: #f0f4ff; }

#rag-help h4, #rag-capabilities h4 {
  margin: 0 0 6px 0;
  font-size: 14px;
  font-weight: bold;
}
#rag-help h4 { color: #1e40af; }
#rag-capabilities h4 { color: #4f46e5; }

#rag-help ul, #rag-capabilities ul { padding-left: 18px; margin: 0; }
#rag-help li { margin-bottom: 6px; line-height: 1.3; color: #1e3a8a; }
#rag-capabilities li { margin-bottom: 6px; line-height: 1.3; color: #3730a3; }

/* Right panel */
#right-panel {
  position: fixed;
  top: 60px;
  right: 20px;
  width: 240px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  max-height: calc(100vh - 80px);
  overflow-y: auto;
  z-index: 1100;
}

.right-block {
  background: #fff;
  border-radius: 12px;
  padding: 10px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

/* Suggested questions */
#suggestions-toggle {
  width: 100%;
  padding: 8px 10px;
  background: #e0e7ff;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
  color: #d97706;
}
#suggestions-toggle:hover { background: #c7d2fe; }

#suggestions-list {
  background: white;
  border-radius: 10px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  overflow: hidden;
  max-height: 0;
  transition: max-height 0.35s ease;
}
#suggestions-list.open { max-height: 300px; }

.suggestion {
  padding: 10px;
  font-size: 13px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
}
.suggestion:hover { background: #f0f4ff; }

/* RAG Flow */
#rag-flow-toggle {
  width: 100%;
  padding: 8px 10px;
  background: #e0e7ff;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
  color: #b91c1c;
}
#rag-flow-toggle:hover { background: #c7d2fe; }

#rag-flow-panel {
  background: #f9f9f9;
  border-radius: 10px;
  padding: 10px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  display: none;
}

.rag-step {
  padding: 6px 10px;
  border-radius: 6px;
  background: #e0e7ff;
  margin-bottom: 4px;
  cursor: pointer;
  font-size: 13px;
}
.rag-step:hover { background: #c7d2fe; }

#rag-step-desc {
  margin-top: 6px;
  font-size: 12px;
  color: #333;
  min-height: 30px;
}

/* Chunk drawer */
#chunk-drawer {
  position: fixed;
  top: 0;
  right: -420px;
  width: 420px;
  height: 100vh;
  background: #ffffff;
  box-shadow: -4px 0 16px rgba(0,0,0,0.15);
  z-index: 2000;
  display: flex;
  flex-direction: column;
  transition: right 0.35s ease;
}
#chunk-drawer.open { right: 0; }

#chunk-drawer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #eee;
  background: #f5f7ff;
  font-weight: bold;
}

#chunk-drawer-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: #b91c1c;
  font-weight: bold;
}

#chunk-drawer-title {
  flex: 1;
  margin-left: 8px;
  white-space: normal;
  overflow: visible;
  font-size: 13px;
  line-height: 1.2;
}

#chunk-drawer-content {
  padding: 16px;
  overflow-y: auto;
  font-size: 13px;
  line-height: 1.5;
  white-space: pre-wrap;
  direction: rtl;
}
#chunk-drawer-content * { direction: ltr; }

.chunk-authors, .chunk-authors-drawer {
  font-size: 12px;
  color: #6b7280;
  margin: 2px 0;
  line-height: 1.3;
}

/* Chunks panel */
#chunks-toggle {
  width: 100%;
  padding: 8px 10px;
  background: #e0e7ff;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  color: #1f2937;
}

#chunks-list {
  margin-top: 8px;
  font-size: 12px;
  max-height: 220px;
  overflow-y: auto;
  display: none;
}
#chunks-list.open { max-height: 400px; display: block; }

.chunk-empty {
  padding: 8px;
  color: #666;
  font-style: italic;
  text-align: center;
}

.chunk-item {
  padding: 8px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
}
.chunk-item:hover { background: #f0f4ff; }

.chunk-doc {
  font-weight: bold;
  font-size: 12px;
  color: #4f46e5;
}

.chunk-preview {
  font-size: 11px;
  color: #333;
  margin-top: 4px;
  line-height: 1.3;
}
  </style>
    
<script>
    // Configurazione di MathJax per interpretare il LaTeX.
// inlineMath -> formule in linea: $...$ oppure \( ... \)
// displayMath -> formule su riga separata: $$...$$ oppure \[ ... \]
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  },
  svg: { fontCache: 'global' }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    
  <button id="toggleSidebar" title="Apri/chiudi storico">‚ò∞ History</button>
  <div id="rag-panel">
  <div id="rag-info">
  <h4>üìä RAG Status</h4>

  <p class="rag-clickable" id="docs-toggle">
    üìÑ Docs: <strong>12</strong>
  </p>
  <div class="rag-expand" id="docs-list">
    <ul>
      <li>A Walk on the Wild Side: A Shape-First Methodology for Orthogonal Drawings </li>
      <li>Graph Drawing: Algorithms for the Visualization of Graphs</li>
      <li>On Turn-Regular Orthogonal Representations</li>
      <li>Computing Bend-Minimum Orthogonal Drawings of Plane Series‚ÄìParallel Graphs
in Linear Time</li>
      <li>On the Complexity of HV-rectilinear Planarity Testing</li>
      <li>On Rectilinear Drawing of Graphs</li>
      <li>Complexity of Finding Non-Planar Rectilinear Drawings of Graphs</li>
      <li>A Linear Algorithm for Optimal Orthogonal Drawings of Triconnected Cubic Plane
Graphs</li>
      <li>Orthogonal Drawings of Plane Graphs without Bends</li>
      <li>Planar Orthogonal and Polyline Drawing Algorithms</li>
      <li>Rectangular Drawing Algorithms</li>
      <li>On embedding a graph in the grid with the minimum number of bends </li>
    </ul>
  </div>

  <p>üîç Retrieval: <strong>Semantic</strong></p>

  <p class="rag-clickable" id="model-toggle">
    üß† Model: <strong>llama3.1:7b</strong>
  </p>
  <div class="rag-expand" id="model-info">
    <p>
      LLaMA 3.1 7B is an open-source model optimized for
      reasoning, RAG, and contextual answers.
      It provides a good balance between quality and speed.
    </p>
  </div>
<p class="rag-clickable" id="embed-toggle">
  üß¨ Embeddings: <strong>mxbai-embed-large</strong>
</p>
<div class="rag-expand" id="embed-info">
  <p>
    mxbai-embed-large is a high-quality embedding model used to encode
    document chunks and queries into dense vectors for semantic retrieval.
  </p>
</div>
  <p>üü¢ Status: <strong>Online</strong></p>
</div>
 <div id="rag-help">
      <h4>üí° How to use</h4>
      <ul>
        <li>Ask questions about the documents</li>
        <li>Request comparisons</li>
        <li>Use natural language</li>
      </ul>
   </div>
   <div id="rag-capabilities">
      <h4>‚öôÔ∏è Capabilities</h4>
      <ul>
        <li>Summaries</li>
        <li>Comparisons</li>
        <li>Citations</li>
        <li>Technical explanations</li>
      </ul>
    </div>
    </div>
  <div id="sidebar" aria-hidden="true">
    <button id="closeSidebar">‚úñ Close</button>
    <button id="newChatBtn">üÜï New Chat</button>
    <h3>Chat History</h3>
    <div class="hint">Click a chat to reload it</div>
    <div id="chatHistory"></div>
  </div>
 
    
  <h1 id="rag-title">ü§ñ RAG Assistant</h1>
  <img src="/static/LogoRag.png" alt="Logo RAG Assistant" id="rag-logo">
  <div id="rag-badge">RAG Active</div>
 <div id="right-panel">

  <!-- Domande suggerite -->
  <div class="right-block">
    <button id="suggestions-toggle">üí° Suggested questions</button>
    <div id="suggestions-list">
      <div class="suggestion">What is the difference between a drawing and a representation?</div>
      <div class="suggestion">Explain the Topology-Shape-Metrics approach</div>
      <div class="suggestion">What does bend minimization mean?</div>
      <div class="suggestion">Are there applications of orthogonal graph drawing?</div>
      <div class="suggestion">What is an HV-rectilinear drawing?</div>
    </div>
  </div>

  <!-- Flusso RAG -->
  <div class="right-block">
    <button id="rag-flow-toggle">üìà RAG Flow</button>
    <div id="rag-flow-panel">
      <div class="rag-step" data-desc="The user submits a natural language query through the interface.">
        0Ô∏è‚É£ User Query
      </div>
      <div class="rag-step" data-desc="The system decides whether the query can be answered directly or requires document retrieval. If no retrieval is needed, a direct response is generated.">
        1Ô∏è‚É£ Query or Respond
      </div>
      <div class="rag-step" data-desc="If retrieval is required, the system applies a hierarchical strategy: deterministic matching for explicit references, otherwise semantic vector-based retrieval.">
        2Ô∏è‚É£ Retrieval
      </div>
      <div class="rag-step" data-desc="The retrieved chunks are used to build the prompt and generate an answer grounded in the source documents.">
        3Ô∏è‚É£ Generation
      </div>
      <div class="rag-step" data-desc="The output is post-processed: formulas are normalized, references are formatted, and relevant images are attached when available.">
        4Ô∏è‚É£ Post-Processing
      </div>
         <div class="rag-step" data-desc="The final grounded answer is returned to the user through the interface.">
        5Ô∏è‚É£ Final Answer
      </div>
      <div id="rag-step-desc"></div>
    </div>
  </div>


  <div class="right-block">
    <button id="chunks-toggle">üìÑ Retrieved Chunks</button>

    <div id="chunks-list" class="empty">
      <div class="chunk-empty">
        No chunks retrieved
      </div>
    </div>
  </div>

</div>
    
  <div id="chat-container">
    <div id="response">
        <div id="placeholder">
          <p>üëã Welcome to the RAG Assistant</p>
          <p>You can ask questions about the loaded documents</p>
          <p><em>Example:</em> ‚ÄúWhat is a graph?‚Äù</p>
        </div>
    </div>
    <div id="input-container">
      <input type="text" id="question" placeholder="Ask a question..." autocomplete="off">
      <button onclick="askQuestion()">Send</button>
    </div>
  </div>
    <!-- Drawer Chunk -->
<div id="chunk-drawer">
  <div id="chunk-drawer-header">
  <button id="chunk-drawer-close">‚úñ</button>
  <span id="chunk-drawer-title"></span>
</div>
  <div id="chunk-drawer-content">
    <!-- testo chunk -->
  </div>
  <script>
    const toggleSidebarBtn = document.getElementById('toggleSidebar');
    const closeSidebarBtn = document.getElementById('closeSidebar');
    const newChatBtn = document.getElementById('newChatBtn');
    const sidebar = document.getElementById('sidebar');
    const chatHistoryDiv = document.getElementById('chatHistory');
// Array che contiene TUTTE le chat fatte
    let chatHistory = [];
    let currentChat = { messages: [], thread_id: null }; // aggiungi thread_id

      // Apre la sidebar con lo storico chat
    toggleSidebarBtn.addEventListener('click', () => {
      sidebar.classList.add('open');
      sidebar.setAttribute('aria-hidden', false);
      toggleSidebarBtn.style.display = 'none';
    });
    // Chiude la sidebar
    closeSidebarBtn.addEventListener('click', () => {
      sidebar.classList.remove('open');
      sidebar.setAttribute('aria-hidden', true);
      toggleSidebarBtn.style.display = 'block';
    });
  // Crea una nuova chat (reset)
  newChatBtn.addEventListener('click', () => {
  const responseDiv = document.getElementById('response');
  responseDiv.innerHTML = ""; // svuota la chat
  
  // Ricrea il placeholder
  const placeholder = document.createElement("div");
  placeholder.id = "placeholder";
  placeholder.innerHTML = `
    <p>üëã Welcome to the RAG Assistant</p>
    <p>You can ask questions about the loaded documents.</p>
    <p><em>Example:</em> ‚ÄúWhat is a graph?‚Äù</p>
  `;
  responseDiv.appendChild(placeholder);

  currentChat = { messages: [], thread_id: null }; // nuova chat
});
// Disegna lo storico chat nella sidebar
    function renderHistory() {
      chatHistoryDiv.innerHTML = "";
      for (let i = chatHistory.length - 1; i >= 0; i--) {
        const div = document.createElement('div');
        div.className = 'chat-entry';
        div.textContent = "Chat " + (i + 1);
        div.addEventListener('click', () => loadChat(i));
        chatHistoryDiv.appendChild(div);
      }
    }
// Ricarica una chat precedente
    function loadChat(index) {
      const entry = chatHistory[index];
     currentChat = { ...entry };
      const responseDiv = document.getElementById('response');
      responseDiv.innerHTML = "";

      entry.messages.forEach(msg => {
        const div = document.createElement('div');
        div.className = 'message ' + (msg.role === 'user' ? 'user' : 'assistant');
        div.innerHTML = msg.content;
        MathJax.typesetPromise([div]);
        responseDiv.appendChild(div);
      });

      sidebar.classList.remove('open');
      sidebar.setAttribute('aria-hidden', 'true');
      toggleSidebarBtn.style.display = 'block';
      responseDiv.scrollTop = responseDiv.scrollHeight;
      document.getElementById('question').focus();
    }
    function typeWriterHTML(element, rawText, htmlText, delay = 20) {
      element.textContent = "";
      let i = 0;

      function addChar() {
        if (i < rawText.length) {
          element.textContent += rawText[i];
          i++;
          element.scrollIntoView({ behavior: "smooth", block: "end" });
          setTimeout(addChar, delay);
        } else {
          // quando finisce il typing ‚Üí inserisce HTML formattato
          element.innerHTML = htmlText;
          MathJax.typesetPromise([element]);
        }
      }

      addChar();
    }

    async function askQuestion() {
  const questionInput = document.getElementById('question');
  const question = questionInput.value.trim();
  if (!question) return;

    //svuota la casella
  questionInput.value = "";
  const placeholder = document.getElementById("placeholder");
  if (placeholder) placeholder.remove();
  const responseDiv = document.getElementById('response');
 //mostra il messaggio utente
  const userMsg = document.createElement('div');
  userMsg.className = 'message user';
  userMsg.textContent = question;
  responseDiv.appendChild(userMsg);
// Messaggio temporaneo del bot mentre Flask elabora
  // Messaggio temporaneo del bot con icona pulsante
 const botMsg = document.createElement('div');
 botMsg.className = 'message assistant';
 botMsg.innerHTML = `<span class="ai-icon">ü§ñ</span> Thinking...`;
 responseDiv.appendChild(botMsg);
 // Resetta il chunk panel ad ogni nuova domanda
  resetChunksUI();
  responseDiv.scrollTop = responseDiv.scrollHeight;

  try {
    const res = await fetch('/ask', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        question,
        thread_id: currentChat.thread_id  // invia l'ID corrente (null solo se nuova chat)
      })
    });
   const data = await res.json();
   const rawText = data.answer;              // testo puro
   const htmlText = marked.parse(rawText);   // HTML finale

   typeWriterHTML(botMsg, rawText, htmlText, 20);
   MathJax.typesetPromise([botMsg]); // <-- specifica il div

     // Aggiorna i chunk recuperati
   updateChunks(data.chunks);   // qui passiamo direttamente i chunk dal server

    // Salva il thread_id solo se non esiste gi√†
    // Salva chat e thread_id
    if (!currentChat.thread_id) currentChat.thread_id = data.thread_id;
    currentChat.messages.push({ role: 'user', content: question });
    currentChat.messages.push({ role: 'assistant', content: botMsg.innerHTML });

    if (!chatHistory.some(c => c.thread_id === currentChat.thread_id)) {
        chatHistory.push({ ...currentChat });
    }

    renderHistory();

} catch (error) {
    botMsg.textContent = "Error connecting to the server.";
}

  responseDiv.scrollTop = responseDiv.scrollHeight;

  questionInput.focus();
}

    document.getElementById('question').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') {
    e.preventDefault();
    askQuestion();
  }
});
const suggestionsToggle = document.getElementById("suggestions-toggle");
const suggestionsList = document.getElementById("suggestions-list");
const questionInput = document.getElementById("question");

suggestionsToggle.addEventListener("click", () => {
  suggestionsList.classList.toggle("open");
});

document.querySelectorAll(".suggestion").forEach(item => {
  item.addEventListener("click", () => {
    questionInput.value = item.textContent;
    questionInput.focus();
  });
});
const docsToggle = document.getElementById("docs-toggle");
const docsList = document.getElementById("docs-list");

const modelToggle = document.getElementById("model-toggle");
const modelInfo = document.getElementById("model-info");

docsToggle.addEventListener("click", () => {
  docsList.classList.toggle("open");
});

modelToggle.addEventListener("click", () => {
  modelInfo.classList.toggle("open");
});
const embedToggle = document.getElementById("embed-toggle");
const embedInfo = document.getElementById("embed-info");

embedToggle.addEventListener("click", () => {
  embedInfo.classList.toggle("open");
});
const ragFlowToggle = document.getElementById("rag-flow-toggle");
const ragFlowPanel = document.getElementById("rag-flow-panel");
const ragStepDesc = document.getElementById("rag-step-desc");

ragFlowToggle.addEventListener("click", () => {
    ragFlowPanel.style.display = (ragFlowPanel.style.display === "block") ? "none" : "block";
    ragStepDesc.textContent = "";
});

document.querySelectorAll(".rag-step").forEach(step => {
    step.addEventListener("click", () => {
        ragStepDesc.textContent = step.getAttribute("data-desc");
    });
});
const chunksToggle = document.getElementById("chunks-toggle");
const chunksList = document.getElementById("chunks-list");

chunksToggle.addEventListener("click", () => {
  chunksList.classList.toggle("open");
});
/* ===== Mappaggio nomi pdf per farli apparire con il vero nome */
const pdfMetadata = {

    "WalkOnTheWildSide.pdf": {
    title: "A Walk on the Wild Side: A Shape-First Methodology for Orthogonal Drawings",
    authors: "Giordano Andreola, Susanna Caroppo, Giuseppe Di Battista, Fabrizio Grosso, Maurizio Patrignani, Allegra Strippoli"
  },
    "GraphDrawing.pdf": {
    title: "Graph Drawing: Algorithms for the Visualization of Graphs",
    authors: "Giuseppe Di Battista,Peter Eades,Roberto Tamassia, Ioannis G.Tollis"
  },
    "OnTurnRegularOrthogonalRepresentation.pdf": {
    title: "On Turn-Regular Orthogonal Representations",
    authors: "Michael A. Bekos, Carla Binucci, Giuseppe Di Battista, Walter Didimo, Martin Gronemann, Karsten Klein, Maurizio Patrignani, Ignaz Rutter"
  },
    "ComputingBendMinimumOrthogonalDrawingsOfPlaneSeriesParallelGraphInLinearTime.pdf": {
    title: "Computing Bend-Minimum Orthogonal Drawings of Plane Series‚ÄìParallel Graphs in Linear Time",
    authors: "Walter Didimo, Michael Kaufmann, Giuseppe Liotta, Giacomo Ortali"
  },
    "OnTheComplexityOfHVRectilinearPlanarityTesting.pdf": {
    title: "On the Complexity of HV-rectilinear Planarity Testing",
    authors: "Walter Didimo, Giuseppe Liotta, and Maurizio Patrignani"
  },
    "OnRectilinearDrawingofGraphs.pdf": {
    title: "On Rectilinear Drawing of Graphs",
    authors: "Peter Eades, Seok-HeeHong, Sheung-Hung Poon"
  },
    "ComplexityOfFindingNonPlanarRectilinearDrawingsofGraph.pdf": {
    title: "Complexity of Finding Non-Planar Rectilinear Drawings of Graphs",
    authors: "Jan Manuch, Murray Patterson, Sheung-Hung Poon, Chris Thachuk"
  },
    "LinearAlgorithmForOptimalOrthogonalDrawingsOfTriconnectedCubicPlaneGraphs.pdf": {
    title: "A Linear Algorithm for Optimal Orthogonal Drawings of Triconnected Cubic Plane Graphs",
    authors: "Md. Saidur Rahman, Shin-ichi Nakano, Takao Nishizeki "
  },
    "OrthogonalDrawingsOfPlaneGraphsWithoutBends.pdf": {
    title: "Orthogonal Drawings of Plane Graphs without Bends",
    authors: "Md. Saidur Rahman, Mahmuda Naznin, Takao Nishizeki"
  },
    "PlanarOrthogonalandPolylineDrawingAlgorithms.pdf": {
    title: "Planar Orthogonal and Polyline Drawing Algorithms",
    authors: "Christian A. Duncan, Michael T. Goodrich"
  },
    "RectangularDrawingAlgorithms.pdf": {
    title: "Rectangular Drawing Algorithms",
    authors: "Takao Nishizeki, Md. Saidur Rahman"
  },
  "OnEmbeddingAGraphInTheGridWithTheMinimumNumberOfBends.pdf": {
    title: "On embedding a graph in the grid with the minimum number of bends",
    authors: "Roberto Tamassia"
  }

};
/* ===== Aggirona i chunk recuperati nella sezione retrived chunk */
function updateChunks(chunks) {
  chunksList.innerHTML = "";

  if (!chunks || chunks.length === 0) {
    chunksList.innerHTML = `
      <div class="chunk-empty">
        No chunks retrieved
      </div>
    `;
    return;
  }

  chunks.forEach(chunk => {
  const div = document.createElement("div");
  div.className = "chunk-item";

  const meta = pdfMetadata[chunk.doc] || {
  title: chunk.doc.replace(".pdf", ""),
  authors: ""
};

div.innerHTML = `
  <div class="chunk-doc">
    üìÑ <strong>${meta.title}</strong>
  </div>
  <div class="chunk-preview">
    ${chunk.text.slice(0, 120)}...
  </div>
`;

  div.addEventListener("click", () => {
    openChunkDrawer(chunk);
  });

  chunksList.appendChild(div);
});
}
const chunkDrawer = document.getElementById("chunk-drawer");
const chunkDrawerTitle = document.getElementById("chunk-drawer-title");
const chunkDrawerContent = document.getElementById("chunk-drawer-content");
const chunkDrawerClose = document.getElementById("chunk-drawer-close");

chunkDrawerClose.addEventListener("click", () => {
  chunkDrawer.classList.remove("open");
});

function openChunkDrawer(chunk) {
  const meta = pdfMetadata[chunk.doc] || {
    title: chunk.doc.replace(".pdf", ""),
    authors: ""
  };

  chunkDrawerTitle.textContent = `üìÑ ${meta.title}`;
  chunkDrawerContent.innerHTML = `
  <div class="chunk-authors-drawer">
    Authors üñãÔ∏è: ${meta.authors}
  </div>
  <div>${chunk.text}</div>
`;
  chunkDrawer.classList.add("open");
}
function resetChunksUI() {
  // chiude lista
  chunksList.classList.remove("open");

  // reset
  chunksList.innerHTML = `
    <div class="chunk-empty">
      No chunks retrieved
    </div>
  `;

  // chiude drawer se aperto
  chunkDrawer.classList.remove("open");
  chunkDrawerTitle.textContent = "üìÑ Chunk";
  chunkDrawerContent.textContent = "";
}
  </script>

</div>
</body>
</html>